## DeepV Code Added Memories
- User is building a Next.js technical articles website with upstream workflow integration from ../deepv-stackoverflow-workflow-complete. The site uses MDX articles with YAML frontmatter, JSON-based article indexing, and supports 10K+ articles across 5 categories: databases, mobile, programming-languages, system-devops, web-frontend. Filename format: {descriptive-title}-{uniqueId}.mdx. Uses 'description' field (not 'excerpt') for SEO. Site has working search, category/subcategory pages, and builds successfully.
- User is building "DeepV Code" - an AI-powered technical documentation platform that automatically transforms Stack Overflow content into enterprise-grade, SEO-optimized articles. This represents the next trend: AI content curation and systematization at scale. Target: 10K+ articles. Architecture: Next.js 15 + TypeScript, designed for search engine dominance. This is likely a serious business venture to compete with GeeksforGeeks/MDN using automated content transformation.
- User's "deepv-stackoverflow-workflow-complete" is an AI pipeline that converts raw Stack Overflow Q&A into comprehensive technical articles with sophisticated metadata (difficulty, readTime, SEO descriptions, technology tags). This automation of technical writing represents a major shift from individual AI content generation to systematic knowledge transformation and curation platforms.
- For this Next.js technical articles website: ALWAYS follow Next.js rules and conventions. Never rebuild existing Next.js functionality. The upstream workflow outputs articles that must match exact format: MDX files with YAML frontmatter, filename format {descriptive-title}-{uniqueId}.mdx, using 'description' field (not excerpt), placed in /content/guides/, with article-index.json updates. Build must always pass without errors.
- Navigation structure: Categories and subcategories are defined in /content/config/categories.json. This is the source of truth for all valid category/subcategory combinations. Always reference this file to understand the site structure. Current categories: databases, mobile, programming-languages, system-devops, web-frontend with their respective subcategories.
- DeepV Code is a Next.js 15 technical documentation platform deployed at https://deepvcode.com/ using ISR architecture. Main repo: git@github.com:thaddeus-git/nextjs-deepv-docs.git, Content repo: git@github.com:thaddeus-git/nextjs-deepv-content.git. Uses external GitHub content fetching with ISR for 100K+ article scalability on Vercel.
- DeepV Code architecture uses content separation strategy: code repository deploys to Vercel (~456KB), content repository stores MDX articles separately. ISR pre-renders only featured articles at build time, generates other pages on-demand. Environment variables needed: CONTENT_REPO_URL and GITHUB_TOKEN for GitHub API content fetching.
- For DeepV Code upstream workflow: articles output to /nextjs-deepv-content/staging/ directory (not main repo), validated then moved to /nextjs-deepv-content/guides/, then git push triggers ISR updates. Uses MDX with YAML frontmatter, filename format {descriptive-title}-{uniqueId}.mdx, requires 'description' field for SEO.
- DeepV Code project configuration is centralized in /config/ directory with project.json (core project info), content-schema.json (MDX article requirements), tech-stack.json (complete technology stack), and README.md (usage guide). This is the authoritative source for all project specifications instead of remembering individual field requirements.
- DeepV Code ISR Content Lifecycle: Upstream generates → /nextjs-deepv-content/staging/guides/ → (optional validation) → move to /nextjs-deepv-content/guides/ → git push → ISR auto-revalidates in 5 minutes. No manual curl commands needed. Two repos: code (nextjs-deepv-docs) and content (nextjs-deepv-content). Schema defined in /config/content-schema.json.
- For DeepV Code architecture: Use schema duplication pattern for decoupling. Main repo owns authoritative schemas, content repo gets copies for independence. Manual sync when schemas change (rare). This ensures zero coupling between repositories while maintaining validation capabilities. Apply this pattern to all shared configuration files.
